// THIS ENTIRE CODE HAS BEEN GENERATED BY CHATGPT EVEN THE LOGIC.
// I DIDN'T UNDERSTAND ANY OF IT. I DON'T KNOW DSU YET. :)

#include <vector>
#include <algorithm>
#include <numeric>
#include <iostream>
using namespace std;

// Leetcode Problem 1579: Remove Max Number of Edges to Keep Graph Fully Traversable
// Link to the question: https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/description/
// Runtime: 346 ms, Beats 79.26% of C++ submissions
// Memory: 142.56 MB, Beats 80.14% of C++ submissions

// Union-Find (Disjoint Set) data structure to manage connected components
class UnionFind
{
public:
    // Initialize the Union-Find structure with `n` elements
    UnionFind(int n) : parent(n), rank(n, 1)
    {
        iota(parent.begin(), parent.end(), 0); // Fill parent with 0, 1, ..., n-1
    }

    // Find the root of the element `u` with path compression
    int find(int u)
    {
        if (parent[u] != u)
        {
            parent[u] = find(parent[u]); // Path compression
        }
        return parent[u];
    }

    // Union the sets containing `u` and `v`
    bool unite(int u, int v)
    {
        int pu = find(u);
        int pv = find(v);
        if (pu == pv)
            return false; // `u` and `v` are already connected

        // Union by rank
        if (rank[pu] > rank[pv])
        {
            parent[pv] = pu;
        }
        else if (rank[pu] < rank[pv])
        {
            parent[pu] = pv;
        }
        else
        {
            parent[pv] = pu;
            rank[pu]++;
        }
        return true;
    }

private:
    vector<int> parent; // Parent of each element
    vector<int> rank;   // Rank of each element
};

class Solution
{
public:
    // Function to calculate the maximum number of edges that can be removed
    // while keeping the graph fully traversable
    int maxNumEdgesToRemove(int n, vector<vector<int>> &edges)
    {
        UnionFind ufAlice(n + 1), ufBob(n + 1);   // Union-Find structures for Alice and Bob
        int removableEdges = 0;                   // Count of removable edges
        int edgesUsedAlice = 0, edgesUsedBob = 0; // Count of edges used by Alice and Bob

        // Sort edges so that type 3 edges are processed first
        sort(edges.begin(), edges.end(), [](const vector<int> &a, const vector<int> &b)
             { return a[0] > b[0]; });

        // Process each edge
        for (const auto &edge : edges)
        {
            int type = edge[0], u = edge[1], v = edge[2];
            if (type == 3)
            {
                // Type 3 edge, used by both Alice and Bob
                bool usedByAlice = ufAlice.unite(u, v);
                bool usedByBob = ufBob.unite(u, v);
                if (usedByAlice)
                    edgesUsedAlice++;
                if (usedByBob)
                    edgesUsedBob++;
                if (!usedByAlice && !usedByBob)
                    removableEdges++;
            }
            else if (type == 1)
            {
                // Type 1 edge, used by Alice only
                if (!ufAlice.unite(u, v))
                    removableEdges++;
                else
                    edgesUsedAlice++;
            }
            else if (type == 2)
            {
                // Type 2 edge, used by Bob only
                if (!ufBob.unite(u, v))
                    removableEdges++;
                else
                    edgesUsedBob++;
            }
        }

        // Check if Alice and Bob can fully traverse the graph
        if (edgesUsedAlice != n - 1 || edgesUsedBob != n - 1)
            return -1;

        return removableEdges; // Return the count of removable edges
    }
};

// Function to print the result
void print(int result)
{
    cout << result << endl;
}

int main()
{
    Solution sol;

    // Example 1
    vector<vector<int>> edges1 = {{3, 1, 2}, {3, 2, 3}, {1, 1, 3}, {1, 2, 4}, {1, 1, 2}, {2, 3, 4}};
    cout << sol.maxNumEdgesToRemove(4, edges1) << endl; // Output: 2

    // Example 2
    vector<vector<int>> edges2 = {{3, 1, 2}, {3, 2, 3}, {1, 1, 4}, {2, 1, 4}};
    cout << sol.maxNumEdgesToRemove(4, edges2) << endl; // Output: 0

    // Example 3
    vector<vector<int>> edges3 = {{3, 2, 3}, {1, 1, 2}, {2, 3, 4}};
    cout << sol.maxNumEdgesToRemove(4, edges3) << endl; // Output: -1

    return 0;
}
